#include <thread>
#include <chrono>
#include <boost/interprocess/streams/vectorstream.hpp>
#include <boost/thread.hpp>

#include <koinos/pack/rt/json_fwd.hpp>

#include <koinos/pack/classes.hpp>
#include <koinos/pack/system_call_ids.hpp>
#include <koinos/plugins/block_producer/block_producer_plugin.hpp>
#include <koinos/pack/rt/binary.hpp>
#include <koinos/pack/rt/json.hpp>
#include <koinos/crypto/multihash.hpp>
#include <koinos/log.hpp>
#include <koinos/util.hpp>

#include <fstream>
#include <iterator>

unsigned char syscall_override_wasm[] = {
  0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x10, 0x03, 0x60,
  0x05, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x00, 0x60, 0x01, 0x7f, 0x00, 0x60,
  0x00, 0x00, 0x02, 0x2d, 0x02, 0x03, 0x65, 0x6e, 0x76, 0x0c, 0x69, 0x6e,
  0x76, 0x6f, 0x6b, 0x65, 0x5f, 0x74, 0x68, 0x75, 0x6e, 0x6b, 0x00, 0x00,
  0x03, 0x65, 0x6e, 0x76, 0x12, 0x69, 0x6e, 0x76, 0x6f, 0x6b, 0x65, 0x5f,
  0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f, 0x63, 0x61, 0x6c, 0x6c, 0x00,
  0x00, 0x03, 0x03, 0x02, 0x01, 0x02, 0x04, 0x05, 0x01, 0x70, 0x01, 0x01,
  0x01, 0x05, 0x03, 0x01, 0x00, 0x02, 0x06, 0x08, 0x01, 0x7f, 0x01, 0x41,
  0xa0, 0x88, 0x04, 0x0b, 0x07, 0x13, 0x02, 0x06, 0x6d, 0x65, 0x6d, 0x6f,
  0x72, 0x79, 0x02, 0x00, 0x06, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x00,
  0x03, 0x0a, 0xf2, 0x05, 0x02, 0xcb, 0x04, 0x01, 0x4e, 0x7f, 0x23, 0x80,
  0x80, 0x80, 0x80, 0x00, 0x21, 0x01, 0x41, 0xa0, 0x01, 0x21, 0x02, 0x20,
  0x01, 0x20, 0x02, 0x6b, 0x21, 0x03, 0x20, 0x03, 0x24, 0x80, 0x80, 0x80,
  0x80, 0x00, 0x41, 0x00, 0x21, 0x04, 0x20, 0x03, 0x20, 0x00, 0x36, 0x02,
  0x9c, 0x01, 0x20, 0x03, 0x20, 0x04, 0x36, 0x02, 0x0c, 0x02, 0x40, 0x03,
  0x40, 0x41, 0x14, 0x21, 0x05, 0x20, 0x03, 0x28, 0x02, 0x0c, 0x21, 0x06,
  0x20, 0x06, 0x21, 0x07, 0x20, 0x05, 0x21, 0x08, 0x20, 0x07, 0x20, 0x08,
  0x49, 0x21, 0x09, 0x41, 0x01, 0x21, 0x0a, 0x20, 0x09, 0x20, 0x0a, 0x71,
  0x21, 0x0b, 0x20, 0x0b, 0x45, 0x0d, 0x01, 0x41, 0x10, 0x21, 0x0c, 0x20,
  0x03, 0x20, 0x0c, 0x6a, 0x21, 0x0d, 0x20, 0x0d, 0x21, 0x0e, 0x20, 0x03,
  0x28, 0x02, 0x0c, 0x21, 0x0f, 0x20, 0x0f, 0x2d, 0x00, 0x80, 0x88, 0x80,
  0x80, 0x00, 0x21, 0x10, 0x20, 0x03, 0x28, 0x02, 0x0c, 0x21, 0x11, 0x41,
  0x01, 0x21, 0x12, 0x20, 0x11, 0x20, 0x12, 0x6a, 0x21, 0x13, 0x20, 0x0e,
  0x20, 0x13, 0x6a, 0x21, 0x14, 0x20, 0x14, 0x20, 0x10, 0x3a, 0x00, 0x00,
  0x20, 0x03, 0x28, 0x02, 0x0c, 0x21, 0x15, 0x41, 0x01, 0x21, 0x16, 0x20,
  0x15, 0x20, 0x16, 0x6a, 0x21, 0x17, 0x20, 0x03, 0x20, 0x17, 0x36, 0x02,
  0x0c, 0x0c, 0x00, 0x0b, 0x0b, 0x41, 0x00, 0x21, 0x18, 0x20, 0x03, 0x20,
  0x18, 0x36, 0x02, 0x0c, 0x03, 0x40, 0x41, 0x00, 0x21, 0x19, 0x20, 0x03,
  0x28, 0x02, 0x9c, 0x01, 0x21, 0x1a, 0x20, 0x03, 0x28, 0x02, 0x0c, 0x21,
  0x1b, 0x20, 0x1a, 0x20, 0x1b, 0x6a, 0x21, 0x1c, 0x20, 0x1c, 0x2d, 0x00,
  0x00, 0x21, 0x1d, 0x41, 0x18, 0x21, 0x1e, 0x20, 0x1d, 0x20, 0x1e, 0x74,
  0x21, 0x1f, 0x20, 0x1f, 0x20, 0x1e, 0x75, 0x21, 0x20, 0x20, 0x19, 0x21,
  0x21, 0x02, 0x40, 0x20, 0x20, 0x45, 0x0d, 0x00, 0x41, 0xea, 0x00, 0x21,
  0x22, 0x20, 0x03, 0x28, 0x02, 0x0c, 0x21, 0x23, 0x20, 0x23, 0x21, 0x24,
  0x20, 0x22, 0x21, 0x25, 0x20, 0x24, 0x20, 0x25, 0x49, 0x21, 0x26, 0x20,
  0x26, 0x21, 0x21, 0x0b, 0x20, 0x21, 0x21, 0x27, 0x41, 0x01, 0x21, 0x28,
  0x20, 0x27, 0x20, 0x28, 0x71, 0x21, 0x29, 0x02, 0x40, 0x20, 0x29, 0x45,
  0x0d, 0x00, 0x41, 0x10, 0x21, 0x2a, 0x20, 0x03, 0x20, 0x2a, 0x6a, 0x21,
  0x2b, 0x20, 0x2b, 0x21, 0x2c, 0x20, 0x03, 0x28, 0x02, 0x9c, 0x01, 0x21,
  0x2d, 0x20, 0x03, 0x28, 0x02, 0x0c, 0x21, 0x2e, 0x20, 0x2d, 0x20, 0x2e,
  0x6a, 0x21, 0x2f, 0x20, 0x2f, 0x2d, 0x00, 0x00, 0x21, 0x30, 0x20, 0x03,
  0x28, 0x02, 0x0c, 0x21, 0x31, 0x41, 0x15, 0x21, 0x32, 0x20, 0x31, 0x20,
  0x32, 0x6a, 0x21, 0x33, 0x41, 0x01, 0x21, 0x34, 0x20, 0x33, 0x20, 0x34,
  0x6b, 0x21, 0x35, 0x41, 0x01, 0x21, 0x36, 0x20, 0x35, 0x20, 0x36, 0x6a,
  0x21, 0x37, 0x20, 0x2c, 0x20, 0x37, 0x6a, 0x21, 0x38, 0x20, 0x38, 0x20,
  0x30, 0x3a, 0x00, 0x00, 0x20, 0x03, 0x28, 0x02, 0x0c, 0x21, 0x39, 0x41,
  0x01, 0x21, 0x3a, 0x20, 0x39, 0x20, 0x3a, 0x6a, 0x21, 0x3b, 0x20, 0x03,
  0x20, 0x3b, 0x36, 0x02, 0x0c, 0x0c, 0x01, 0x0b, 0x0b, 0x41, 0xcd, 0xea,
  0xb7, 0xfb, 0x78, 0x21, 0x3c, 0x41, 0x00, 0x21, 0x3d, 0x41, 0x10, 0x21,
  0x3e, 0x20, 0x03, 0x20, 0x3e, 0x6a, 0x21, 0x3f, 0x20, 0x3f, 0x21, 0x40,
  0x20, 0x03, 0x28, 0x02, 0x0c, 0x21, 0x41, 0x41, 0x15, 0x21, 0x42, 0x20,
  0x41, 0x20, 0x42, 0x6a, 0x21, 0x43, 0x41, 0x01, 0x21, 0x44, 0x20, 0x43,
  0x20, 0x44, 0x6b, 0x21, 0x45, 0x20, 0x03, 0x20, 0x45, 0x3a, 0x00, 0x10,
  0x20, 0x03, 0x28, 0x02, 0x0c, 0x21, 0x46, 0x41, 0x15, 0x21, 0x47, 0x20,
  0x46, 0x20, 0x47, 0x6a, 0x21, 0x48, 0x41, 0x01, 0x21, 0x49, 0x20, 0x48,
  0x20, 0x49, 0x6b, 0x21, 0x4a, 0x41, 0x01, 0x21, 0x4b, 0x20, 0x4a, 0x20,
  0x4b, 0x6a, 0x21, 0x4c, 0x20, 0x3c, 0x20, 0x3d, 0x20, 0x3d, 0x20, 0x40,
  0x20, 0x4c, 0x10, 0x80, 0x80, 0x80, 0x80, 0x00, 0x41, 0xa0, 0x01, 0x21,
  0x4d, 0x20, 0x03, 0x20, 0x4d, 0x6a, 0x21, 0x4e, 0x20, 0x4e, 0x24, 0x80,
  0x80, 0x80, 0x80, 0x00, 0x0f, 0x0b, 0xa2, 0x01, 0x01, 0x13, 0x7f, 0x23,
  0x80, 0x80, 0x80, 0x80, 0x00, 0x21, 0x00, 0x41, 0xd0, 0x00, 0x21, 0x01,
  0x20, 0x00, 0x20, 0x01, 0x6b, 0x21, 0x02, 0x20, 0x02, 0x24, 0x80, 0x80,
  0x80, 0x80, 0x00, 0x20, 0x02, 0x21, 0x03, 0x41, 0x00, 0x21, 0x04, 0x41,
  0x98, 0xc3, 0xee, 0xfd, 0x79, 0x21, 0x05, 0x41, 0x3f, 0x21, 0x06, 0x41,
  0x00, 0x21, 0x07, 0x20, 0x05, 0x20, 0x03, 0x20, 0x06, 0x20, 0x07, 0x20,
  0x07, 0x10, 0x81, 0x80, 0x80, 0x80, 0x00, 0x20, 0x02, 0x2d, 0x00, 0x00,
  0x21, 0x08, 0x41, 0x18, 0x21, 0x09, 0x20, 0x08, 0x20, 0x09, 0x74, 0x21,
  0x0a, 0x20, 0x0a, 0x20, 0x09, 0x75, 0x21, 0x0b, 0x41, 0x01, 0x21, 0x0c,
  0x20, 0x0b, 0x20, 0x0c, 0x6a, 0x21, 0x0d, 0x20, 0x03, 0x20, 0x0d, 0x6a,
  0x21, 0x0e, 0x20, 0x0e, 0x20, 0x04, 0x3a, 0x00, 0x00, 0x41, 0x02, 0x21,
  0x0f, 0x20, 0x03, 0x20, 0x0f, 0x6a, 0x21, 0x10, 0x20, 0x10, 0x10, 0x82,
  0x80, 0x80, 0x80, 0x00, 0x41, 0xd0, 0x00, 0x21, 0x11, 0x20, 0x02, 0x20,
  0x11, 0x6a, 0x21, 0x12, 0x20, 0x12, 0x24, 0x80, 0x80, 0x80, 0x80, 0x00,
  0x0f, 0x0b, 0x0b, 0x1c, 0x01, 0x00, 0x41, 0x80, 0x08, 0x0b, 0x15, 0x4b,
  0x4f, 0x49, 0x4e, 0x4f, 0x53, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65,
  0x20, 0x4d, 0x6f, 0x6f, 0x6e, 0x3a, 0x20, 0x00, 0x00, 0x3a, 0x04, 0x6e,
  0x61, 0x6d, 0x65, 0x01, 0x33, 0x04, 0x00, 0x0c, 0x69, 0x6e, 0x76, 0x6f,
  0x6b, 0x65, 0x5f, 0x74, 0x68, 0x75, 0x6e, 0x6b, 0x01, 0x12, 0x69, 0x6e,
  0x76, 0x6f, 0x6b, 0x65, 0x5f, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x5f,
  0x63, 0x61, 0x6c, 0x6c, 0x02, 0x06, 0x70, 0x72, 0x69, 0x6e, 0x74, 0x73,
  0x03, 0x06, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x00, 0x26, 0x09, 0x70,
  0x72, 0x6f, 0x64, 0x75, 0x63, 0x65, 0x72, 0x73, 0x01, 0x0c, 0x70, 0x72,
  0x6f, 0x63, 0x65, 0x73, 0x73, 0x65, 0x64, 0x2d, 0x62, 0x79, 0x01, 0x05,
  0x63, 0x6c, 0x61, 0x6e, 0x67, 0x06, 0x31, 0x30, 0x2e, 0x30, 0x2e, 0x30
};
unsigned int syscall_override_wasm_len = 1008;

namespace koinos::plugins::block_producer {

using namespace koinos::types;

using vectorstream = boost::interprocess::basic_vectorstream< std::vector< char > >;

static types::timestamp_type timestamp_now()
{
   auto duration = std::chrono::system_clock::now().time_since_epoch();
   auto ticks = std::chrono::duration_cast< std::chrono::milliseconds >( duration ).count();

   types::timestamp_type t;
   t = ticks;
   return t;
}

std::shared_ptr< protocol::block_header > block_producer_plugin::produce_block()
{
   // Make block header
   auto block = std::make_shared< protocol::block_header >();

   // Make active data, fetch timestamp
   protocol::active_block_data active_data;
   active_data.timestamp = timestamp_now();

   // Get previous block data
   rpc::block_topology topology;
   rpc::query_param_item p = rpc::get_head_info_params();
   vectorstream ostream;
   pack::to_binary( ostream, p );
   crypto::variable_blob query_bytes{ ostream.vector() };
   rpc::query_submission query{ query_bytes };
   auto& controller = appbase::app().get_plugin< chain::chain_plugin >().controller();
   auto r = controller.submit( rpc::submission_item( query ) );
   rpc::query_item_result q;
   try
   {
      auto w = std::get< rpc::query_submission_result >( *(r.get()) );
      vectorstream istream( w.result );
      pack::from_binary( istream, q );
      std::visit( koinos::overloaded {
         [&]( rpc::get_head_info_result& head_info ) {
            active_data.height = head_info.height + 1;
            topology.previous = head_info.id;
            topology.height = active_data.height;
         },
         []( auto& ){}
      }, q );
   }
   catch ( const std::exception &e )
   {
      LOG(error) << e.what();
   }

   // Check if special demo block, call proper function to add transactions
   if( wasm )
   {
      if (topology.height == 1) { demo_create_contract(active_data); }
      else if ( topology.height == 2) { demo_call_contract(active_data); }
      else if ( topology.height == 3 ) { override_prints( active_data ); }
      else if ( topology.height == 4 ) { demo_call_contract(active_data); }
   }

   // Serialize active data, store it in block header
   vectorstream active_stream;
   pack::to_binary( active_stream, active_data );
   crypto::variable_blob active_data_bytes{ active_stream.vector() };
   block->active_bytes = active_data_bytes;

   // Hash active data and use it to sign block
   protocol::passive_block_data passive_data;
   auto digest = crypto::hash( CRYPTO_SHA2_256_ID, active_data );
   auto signature = block_signing_private_key.sign_compact( digest );
   passive_data.block_signature = signature;

   // Hash passive data
   auto passive_hash = crypto::hash( CRYPTO_SHA2_256_ID, passive_data );
   block->passive_merkle_root = passive_hash;
   block->active_bytes = active_data_bytes;

   // Serialize the header
   vectorstream header_stream;
   pack::to_binary( header_stream, *block );
   crypto::variable_blob block_header_bytes{ header_stream.vector() };

   // Store hash of header as ID
   topology.id = crypto::hash( CRYPTO_SHA2_256_ID, *block );

   // Serialize the passive data
   vectorstream passive_stream;
   pack::to_binary( passive_stream, passive_data );
   crypto::variable_blob passive_data_bytes{ passive_stream.vector() };

   // Create the submit block object
   rpc::block_submission block_submission;
   block_submission.topology = topology;
   block_submission.header_bytes = block_header_bytes;
   block_submission.passives_bytes.push_back( passive_data_bytes );


   // Submit the block
   rpc::submission_item si = block_submission;
   r = controller.submit( si );
   try
   {
      r.get(); // TODO: Probably should do something better here, rather than discarding the result...
   }
   catch ( const std::exception &e )
   {
      LOG(error) << e.what();
   }

   LOG(info) << "produced block: " << topology;

   return block;
}

block_producer_plugin::block_producer_plugin() {}
block_producer_plugin::~block_producer_plugin() {}

void block_producer_plugin::set_program_options( options_description& cli, options_description& cfg )
{
   cfg.add_options()
         ("target-wasm", bpo::value<bfs::path>(),
            "the location of a demo wasm file (absolute path or relative to application data dir)")
         ;
}

void block_producer_plugin::plugin_initialize( const appbase::variables_map& options )
{
   std::string seed = "test seed";

   block_signing_private_key = crypto::private_key::regenerate( crypto::hash_str( CRYPTO_SHA2_256_ID, seed.c_str(), seed.size() ) );

   if( options.count("target-wasm") )
   {
      auto wasm_target = options.at("target-wasm").as<bfs::path>();
      if( !bfs::is_directory( wasm_target ) )
      {
         if( wasm_target.is_relative() )
            wasm = appbase::app().data_dir() / wasm_target;
         else
            wasm = wasm_target;
      }
   }
}

void block_producer_plugin::plugin_startup()
{
   start_block_production();
}

void block_producer_plugin::plugin_shutdown()
{
   stop_block_production();
}

void block_producer_plugin::start_block_production()
{
   producing_blocks = true;

   block_production_thread = std::make_shared< std::thread >( [&]() {
      std::this_thread::sleep_for( std::chrono::milliseconds( 1000 ) );

      while ( producing_blocks )
      {
         auto block = produce_block();

         // Sleep for the block production time
         std::this_thread::sleep_for( std::chrono::milliseconds( KOINOS_BLOCK_TIME_MS ) );
      }
   } );
}

void block_producer_plugin::stop_block_production()
{
   producing_blocks = false;

   if ( block_production_thread )
      block_production_thread->join();

   block_production_thread.reset();
}

void block_producer_plugin::override_prints( types::protocol::active_block_data& active_data )
{
   LOG(info) << "Uploading prints override";

   // Create the operation, fill the contract code
   // We will leave extensions and id at default for now
   types::protocol::create_system_contract_operation create_op;
   create_op.bytecode.resize( syscall_override_wasm_len );
   memcpy( create_op.bytecode.data(), syscall_override_wasm, syscall_override_wasm_len );

   auto id = crypto::hash( CRYPTO_RIPEMD160_ID, 2 );
   for (int i = 0; i < 20; i++) { create_op.contract_id[i] = id.digest[i]; }

   types::protocol::operation o = create_op;

   types::protocol::transaction_type transaction;
   transaction.operations.push_back(pack::to_variable_blob( o ) );

   types::protocol::set_system_call_operation set_op;
   set_op.call_id = (uint32_t)types::system::system_call_id::prints;
   types::system::contract_call_bundle call_bundle;
   for (int i = 0; i < 20; i++) { call_bundle.contract_id[i] = id.digest[i]; }
   call_bundle.entry_point = 0;
   set_op.target = call_bundle;

   o = set_op;

   transaction.operations.push_back(pack::to_variable_blob( o ) );

   active_data.transactions.push_back(pack::to_variable_blob( transaction ) );
}

void block_producer_plugin::demo_create_contract( types::protocol::active_block_data& active_data )
{
   LOG(info) << "Creating contract";

   // Create the operation, fill the contract code
   // We will leave extensions and id at default for now
   types::protocol::create_system_contract_operation create_op;
   LOG(info) << wasm->native();
   std::fstream wasm_stream( wasm->native() );
   std::istreambuf_iterator< char > wasm_itr( wasm_stream );
   std::istreambuf_iterator< char > end;
   create_op.bytecode.insert( create_op.bytecode.end(), wasm_itr, end );
   LOG(info) << create_op.bytecode.size();

   auto id = crypto::hash( CRYPTO_RIPEMD160_ID, 1 );
   for (int i = 0; i < 20; i++) { create_op.contract_id[i] = id.digest[i]; }

   types::protocol::operation o = create_op;

   types::protocol::transaction_type transaction;
   transaction.operations.push_back(pack::to_variable_blob( o ) );

   active_data.transactions.push_back(pack::to_variable_blob( transaction ) );
}

void block_producer_plugin::demo_call_contract( types::protocol::active_block_data& active_data )
{
   types::protocol::contract_call_operation call_op;

   auto id = crypto::hash( CRYPTO_RIPEMD160_ID, 1 );
   for (int i = 0; i < 20; i++) { call_op.contract_id[i] = id.digest[i]; }

   LOG(info) << "Calling contract";
   types::protocol::operation o = call_op;

   types::protocol::transaction_type transaction;
   transaction.operations.push_back( pack::to_variable_blob( o ) );
   active_data.transactions.push_back( pack::to_variable_blob( transaction ) );
}

} // koinos::plugins::block_producer
